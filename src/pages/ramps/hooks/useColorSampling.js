// app/ramps/hooks/useColorSampling.js
/**
 * React hook for color sampling with performance optimizations
 */
import React, { useState, useCallback, useRef, useEffect } from 'react'
import { 
  generateColorSwatch, 
  updatePerformanceStats,
  calculateLuminance 
} from '../utils/colorUtils'
import { 
  debounce, 
  throttle, 
  showNotification,
  measurePerformance 
} from '../utils/performanceUtils'

export function useColorSampling() {
  const [generatedColors, setGeneratedColors] = useState([])
  const [samplePositions, setSamplePositions] = useState([])
  const [isProcessing, setIsProcessing] = useState(false)
  const [luminanceMode, setLuminanceMode] = useState('hsv') // 'hsv' or 'ciel'

  // Refs for canvas operations
  const canvasRef = useRef(null)
  const ctxRef = useRef(null)

  /**
   * Set canvas reference for sampling operations
   */
  const setCanvasRef = useCallback((canvas, ctx) => {
    canvasRef.current = canvas
    ctxRef.current = ctx
  }, [])

  /**
   * Generate color swatch with performance optimization
   */
  const generateSwatch = useCallback((options = {}) => {
    if (!canvasRef.current || !ctxRef.current) {
      console.warn('Canvas not ready for sampling')
      return
    }

    const perf = measurePerformance('generateSwatch')
    setIsProcessing(true)
    updatePerformanceStats()

    try {
      const result = generateColorSwatch(
        canvasRef.current, 
        ctxRef.current, 
        {
          luminanceMode,
          ...options
        }
      )

      setGeneratedColors(result.colors)
      setSamplePositions(result.positions)
      
      const duration = perf.end()
      showNotification(`Swatch generated (${Math.round(duration)}ms)`)
      
    } catch (error) {
      console.error('Error generating swatch:', error)
      showNotification('Failed to generate swatch', 'error')
    } finally {
      setIsProcessing(false)
    }
  }, [luminanceMode])

  /**
   * Debounced swatch generation for expensive operations
   */
  const debouncedGenerateSwatch = useCallback((options = {}) => {
    debounce('generate-swatch', () => generateSwatch(options), 200)
  }, [generateSwatch])

  /**
   * Throttled swatch generation for frequent operations like slider changes
   */
  const throttledGenerateSwatch = useCallback((options = {}) => {
    throttle('generate-swatch-throttled', () => generateSwatch(options), 100)
  }, [generateSwatch])

  /**
   * Update luminance mode and recalculate if needed
   */
  const updateLuminanceMode = useCallback((mode) => {
    setLuminanceMode(mode)
    
    // Recalculate luminance for existing colors
    if (generatedColors.length > 0) {
      const updatedColors = generatedColors.map(color => ({
        ...color,
        luminance: calculateLuminance(color.r, color.g, color.b, mode)
      }))
      setGeneratedColors(updatedColors)
    }
    
    showNotification(`Luminance mode: ${mode === 'hsv' ? 'HSV' : 'CIE L*'}`)
  }, [generatedColors])

  /**
   * Reverse the current color array
   */
  const reverseColors = useCallback(() => {
    if (generatedColors.length === 0) {
      showNotification('No colors to reverse!', 'error')
      return
    }

    setGeneratedColors(prev => [...prev].reverse())
    setSamplePositions(prev => [...prev].reverse())
    showNotification('Colors reversed!')
  }, [generatedColors])

  /**
   * Clear current swatch
   */
  const clearSwatch = useCallback(() => {
    setGeneratedColors([])
    setSamplePositions([])
    showNotification('Swatch cleared')
  }, [])

  /**
   * Get swatch as GPL format string
   */
  const getGPLContent = useCallback((swatchName = 'Current Swatch') => {
    if (generatedColors.length === 0) return ''

    let gplContent = 'GIMP Palette\n'
    gplContent += `Name: ${swatchName}\n`
    gplContent += 'Columns: 11\n'
    gplContent += '# Generated by Gradient Color Sampler v7.0\n'
    gplContent += '#\n'

    generatedColors.forEach((color, index) => {
      const r = color.r.toString().padStart(3)
      const g = color.g.toString().padStart(3)
      const b = color.b.toString().padStart(3)
      gplContent += `${r} ${g} ${b}    Color ${index}\n`
    })

    return gplContent
  }, [generatedColors])

  /**
   * Export swatch as PNG (11x1 pixels)
   */
  const exportAsPNG = useCallback((filename = 'color-ramp') => {
    if (generatedColors.length === 0) {
      showNotification('No colors to export!', 'error')
      return
    }

    const canvas = document.createElement('canvas')
    canvas.width = 11
    canvas.height = 1
    const ctx = canvas.getContext('2d')

    generatedColors.forEach((color, index) => {
      ctx.fillStyle = color.hex
      ctx.fillRect(index, 0, 1, 1)
    })

    canvas.toBlob((blob) => {
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `${filename}.png`
      a.click()
      URL.revokeObjectURL(url)
      showNotification('PNG exported!')
    }, 'image/png')
  }, [generatedColors])

  /**
   * Export swatch as GPL file
   */
  const exportAsGPL = useCallback((filename = 'color-ramp', swatchName = 'Current Swatch') => {
    if (generatedColors.length === 0) {
      showNotification('No colors to export!', 'error')
      return
    }

    const gplContent = getGPLContent(swatchName)
    const blob = new Blob([gplContent], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `${filename}.gpl`
    a.click()
    URL.revokeObjectURL(url)
    showNotification('GPL file exported!')
  }, [getGPLContent, generatedColors])

  return {
    // State
    generatedColors,
    samplePositions,
    isProcessing,
    luminanceMode,
    
    // Canvas management
    setCanvasRef,
    
    // Sampling operations
    generateSwatch,
    debouncedGenerateSwatch,
    throttledGenerateSwatch,
    
    // Color operations
    reverseColors,
    clearSwatch,
    
    // Settings
    updateLuminanceMode,
    
    // Export operations
    getGPLContent,
    exportAsPNG,
    exportAsGPL,
    
    // Computed values
    hasColors: generatedColors.length > 0,
    colorCount: generatedColors.length
  }
}
